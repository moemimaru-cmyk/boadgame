import React, { useState, useRef, useEffect } from 'react';
import { 
  Paintbrush, 
  Trophy, 
  User, 
  Check, 
  Palette, 
  RefreshCw, 
  ChevronRight, 
  Play, 
  Award, 
  RotateCcw, 
  Timer, 
  Pause, 
  HelpCircle, 
  X, 
  Type, 
  Image as ImageIcon 
} from 'lucide-react';

// --- Constants ---
const MAX_PLAYERS = 7;
const MIN_PLAYERS = 3;

const COLORS = [
  '#000000', '#57534E', '#A8A29E', '#FFFFFF',
  '#EF4444', '#FCA5A5', '#F97316', '#FDBA74',
  '#EAB308', '#FEF08A', '#22C55E', '#86EFAC',
  '#06B6D4', '#67E8F9', '#3B82F6', '#93C5FD',
  '#A855F7', '#D8B4FE', '#EC4899', '#F9A8D4',
  '#78350F', '#FDE68A',
];

// --- Components ---

const Button = ({ onClick, children, className = "", variant = "primary", disabled = false }) => {
  const baseStyle = "px-6 py-3 rounded-full font-bold transition-all transform active:scale-95 shadow-lg flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed";
  const variants = {
    primary: "bg-yellow-600 hover:bg-yellow-700 text-white border-2 border-yellow-400",
    secondary: "bg-gray-800 hover:bg-gray-700 text-white border-2 border-gray-600",
    success: "bg-green-600 hover:bg-green-700 text-white border-2 border-green-400",
    danger: "bg-red-600 hover:bg-red-700 text-white border-2 border-red-400",
    dark: "bg-stone-800 hover:bg-stone-700 text-white border-2 border-stone-600",
  };
  return (
    <button onClick={onClick} className={`${baseStyle} ${variants[variant]} ${className}`} disabled={disabled}>
      {children}
    </button>
  );
};

const PresentationTimer = () => {
  const [timeLeft, setTimeLeft] = useState(60);
  const [isActive, setIsActive] = useState(false);

  useEffect(() => {
    let interval = null;
    if (isActive && timeLeft > 0) {
      interval = setInterval(() => {
        setTimeLeft((prev) => prev - 1);
      }, 1000);
    } else if (timeLeft === 0) {
      setIsActive(false);
    }
    return () => clearInterval(interval);
  }, [isActive, timeLeft]);

  const toggle = () => setIsActive(!isActive);
  const reset = () => {
    setIsActive(false);
    setTimeLeft(60);
  };

  return (
    <div className="flex flex-col items-center justify-center p-3 bg-stone-800 rounded-xl border border-stone-600 mb-6 w-full max-w-xs mx-auto shadow-inner">
      <div className="flex items-center gap-4 mb-2">
        <Timer className="text-stone-400" size={20} />
        <span className="text-sm text-stone-300">プレゼン用タイマー (60秒)</span>
      </div>
      
      <div className={`text-4xl font-mono font-bold mb-3 ${timeLeft <= 10 && timeLeft > 0 ? 'text-red-500 animate-pulse' : timeLeft === 0 ? 'text-red-600' : 'text-white'}`}>
        00:{timeLeft.toString().padStart(2, '0')}
      </div>

      <div className="flex gap-2 w-full">
        <button 
          onClick={toggle} 
          className={`flex-1 py-2 rounded-lg font-bold flex items-center justify-center gap-2 transition-colors ${isActive ? 'bg-yellow-700 text-yellow-100 hover:bg-yellow-600' : 'bg-green-700 text-green-100 hover:bg-green-600'}`}
        >
          {isActive ? <><Pause size={16}/> 停止</> : <><Play size={16}/> スタート</>}
        </button>
        <button 
          onClick={reset} 
          className="px-4 py-2 bg-stone-600 hover:bg-stone-500 text-stone-200 rounded-lg flex items-center justify-center"
          title="リセット"
        >
          <RotateCcw size={16} />
        </button>
      </div>
    </div>
  );
};

const RuleModal = ({ onClose }) => {
  return (
    <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4 animate-fadeIn">
      <div className="bg-stone-800 text-stone-100 max-w-lg w-full rounded-2xl border border-stone-600 shadow-2xl overflow-hidden flex flex-col max-h-[90vh]">
        <div className="p-4 border-b border-stone-700 flex justify-between items-center bg-stone-900">
          <h2 className="text-xl font-bold text-yellow-500 flex items-center gap-2">
            <HelpCircle size={24} /> 遊び方
          </h2>
          <button onClick={onClose} className="p-1 hover:bg-stone-700 rounded-full transition-colors">
            <X size={24} />
          </button>
        </div>
        
        <div className="p-6 overflow-y-auto leading-relaxed text-sm sm:text-base">
          <ol className="list-decimal pl-5 space-y-4 marker:text-yellow-500 marker:font-bold">
            <li>
              <strong className="text-white block mb-1">プレイヤー登録</strong>
              参加者の名前を入力します。
            </li>
            <li>
              <strong className="text-white block mb-1">描画フェーズ</strong>
              1人ずつ端末を受け取り、何も考えずに適当に線や形を描きます（制限時間タイマー付き）。
            </li>
            <li>
              <strong className="text-white block mb-1">鑑賞会フェーズ</strong>
              <ul className="list-disc pl-5 space-y-2 mt-1 marker:text-stone-500">
                <li>描かれた絵が「額縁」に入って厳かに表示されます。</li>
                <li>作者以外の人たちが、<span className="text-yellow-400 font-bold">その絵のタイトルを述べてから</span>、その絵がいかに素晴らしいかを批評します。</li>
                <li>この時、考えたタイトルをアプリに入力しておきます。</li>
                <li>作者は「一番感動した批評とタイトル」をアプリ上でタップして勝者を決めます。</li>
              </ul>
            </li>
            <li>
              <strong className="text-white block mb-1">結果発表・美術館</strong>
              全員の絵が終わると「ベストキュレーター」が発表され、最後に全員の作品が並ぶ美術館へ移動できます。
            </li>
          </ol>
        </div>
        
        <div className="p-4 border-t border-stone-700 bg-stone-900 text-center">
          <Button onClick={onClose} className="w-full">
            閉じる
          </Button>
        </div>
      </div>
    </div>
  );
};

const DrawingCanvas = ({ onSave, playerName }) => {
  const canvasRef = useRef(null);
  const containerRef = useRef(null);
  const [isDrawing, setIsDrawing] = useState(false);
  const [color, setColor] = useState('#000000');
  const [brushSize, setBrushSize] = useState(3);
  const [timeLeft, setTimeLeft] = useState(60); 
  const [hasDrawn, setHasDrawn] = useState(false);

  useEffect(() => {
    const canvas = canvasRef.current;
    const container = containerRef.current;
    if (!canvas || !container) return;

    const ctx = canvas.getContext('2d');
    
    const setCanvasSize = () => {
      const width = container.clientWidth;
      const height = container.clientHeight;
      
      if (width === 0 || height === 0) {
          requestAnimationFrame(setCanvasSize);
          return;
      }

      const dpr = window.devicePixelRatio || 1;
      
      let tempImage = null;
      if (canvas.width > 0 && canvas.height > 0) {
          try {
              tempImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
          } catch(e) {}
      }

      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;
      
      ctx.scale(dpr, dpr);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      if (!tempImage) {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, width, height);
      } else {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, width, height);
      }
    };
    
    const frameId = requestAnimationFrame(setCanvasSize);
    window.addEventListener('resize', setCanvasSize);

    const timer = setInterval(() => {
      setTimeLeft((prev) => {
        if (prev <= 0) return 0;
        return prev - 1;
      });
    }, 1000);

    return () => {
      cancelAnimationFrame(frameId);
      window.removeEventListener('resize', setCanvasSize);
      clearInterval(timer);
    };
  }, []);

  const getCoordinates = (e) => {
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    
    let clientX, clientY;

    if (e.changedTouches) {
      clientX = e.changedTouches[0].clientX;
      clientY = e.changedTouches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }

    return {
      offsetX: (clientX - rect.left), 
      offsetY: (clientY - rect.top)
    };
  };

  const startDrawing = (e) => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const { offsetX, offsetY } = getCoordinates(e);

    ctx.beginPath();
    ctx.moveTo(offsetX, offsetY);
    setIsDrawing(true);
    setHasDrawn(true);
  };

  const draw = (e) => {
    if (!isDrawing) return;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const { offsetX, offsetY } = getCoordinates(e);

    ctx.lineTo(offsetX, offsetY);
    ctx.strokeStyle = color;
    ctx.lineWidth = brushSize;
    ctx.stroke();
  };

  const stopDrawing = () => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    ctx.closePath();
    setIsDrawing(false);
  };

  const clearCanvas = () => {
    const canvas = canvasRef.current;
    const container = containerRef.current;
    const ctx = canvas.getContext('2d');
    const width = container.clientWidth;
    const height = container.clientHeight;
    
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, width, height);
    setHasDrawn(false);
  };

  const handleSave = () => {
    const canvas = canvasRef.current;
    const dataUrl = canvas.toDataURL();
    onSave(dataUrl);
  };

  return (
    <div className="flex flex-col h-full w-full max-w-2xl mx-auto p-4 bg-gray-900 rounded-xl shadow-2xl border-4 border-gray-700">
      <div className="flex justify-between items-center mb-2 text-white">
        <div>
          <h2 className="text-xl font-serif">Artist: <span className="text-yellow-400 font-bold">{playerName}</span></h2>
          <p className="text-sm text-gray-400">何も考えずに描いてください！</p>
        </div>
        <div className={`text-2xl font-mono font-bold ${timeLeft < 10 ? 'text-red-500 animate-pulse' : 'text-white'}`}>
          {Math.floor(timeLeft / 60)}:{(timeLeft % 60).toString().padStart(2, '0')}
        </div>
      </div>

      <div 
        ref={containerRef}
        className="flex-grow bg-white rounded-lg overflow-hidden relative touch-none border-2 border-gray-600 mb-2" 
        style={{ minHeight: '300px' }}
      >
        <canvas
          ref={canvasRef}
          onMouseDown={startDrawing}
          onMouseMove={draw}
          onMouseUp={stopDrawing}
          onMouseLeave={stopDrawing}
          onTouchStart={startDrawing}
          onTouchMove={draw}
          onTouchEnd={stopDrawing}
          className="block w-full h-full cursor-crosshair touch-none"
          style={{ touchAction: 'none' }} 
        />
      </div>

      <div className="bg-gray-800 p-3 rounded-lg flex flex-col gap-3">
        <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-thin scrollbar-thumb-gray-600">
          {COLORS.map((c) => (
             <button
              key={c}
              onClick={() => setColor(c)}
              className={`flex-shrink-0 w-8 h-8 rounded-full border-2 transition-transform ${color === c ? 'border-white scale-110 shadow-lg ring-2 ring-yellow-500' : 'border-gray-600'}`}
              style={{ backgroundColor: c }}
              title={c}
            />
          ))}
        </div>
        
        <div className="flex flex-wrap items-center gap-4 text-white text-xs">
           <div className="flex flex-col flex-grow">
             <span className="mb-1 ml-1 text-gray-400">太さ: {brushSize}px</span>
             <input 
               type="range" 
               min="1" 
               max="30" 
               value={brushSize} 
               onChange={(e) => setBrushSize(parseInt(e.target.value))}
               className="w-full accent-yellow-500 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer"
             />
           </div>

           <button 
             onClick={clearCanvas} 
             className="p-3 bg-gray-700 rounded-lg hover:bg-gray-600 text-white flex-shrink-0 flex items-center justify-center gap-1" 
             title="全消去"
           >
             <RefreshCw size={16} /> <span className="hidden sm:inline">Clear</span>
           </button>
        </div>
      </div>

      <div className="mt-4 flex justify-end">
        <Button onClick={handleSave} disabled={!hasDrawn}>
          描き終わった <Check size={20} />
        </Button>
      </div>
    </div>
  );
};

// --- Main App Logic ---

export default function App() {
  const [phase, setPhase] = useState('setup'); // setup, drawing, interlude, presenting, voting, result, gallery
  const [players, setPlayers] = useState([]);
  const [currentInput, setCurrentInput] = useState('');
  const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
  const [drawings, setDrawings] = useState({}); 
  const [scores, setScores] = useState({}); 
  const [currentPresenterIndex, setCurrentPresenterIndex] = useState(0);
  const [showRules, setShowRules] = useState(false); 
  
  // State for Titles: { [artistId]: { [criticId]: "Title" } }
  const [titles, setTitles] = useState({});
  // State for recording who won for each painting: { [artistId]: winningCriticId }
  const [paintingWinners, setPaintingWinners] = useState({});

  // --- Handlers ---

  const addPlayer = (e) => {
    e.preventDefault();
    if (currentInput.trim() && players.length < MAX_PLAYERS) {
      const newPlayer = {
        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
        name: currentInput.trim(),
      };
      setPlayers([...players, newPlayer]);
      setScores(prev => ({ ...prev, [newPlayer.id]: 0 }));
      setCurrentInput('');
    }
  };

  const removePlayer = (id) => {
    setPlayers(players.filter(p => p.id !== id));
    const newScores = { ...scores };
    delete newScores[id];
    setScores(newScores);
  };

  const startGame = () => {
    if (players.length < MIN_PLAYERS) {
      console.error(`最低${MIN_PLAYERS}人のプレイヤーが必要です！`); 
      return;
    }
    setPhase('drawing');
    setCurrentPlayerIndex(0);
    setTitles({}); 
    setPaintingWinners({});
  };

  const handleDrawingSave = (dataUrl) => {
    const currentPlayer = players[currentPlayerIndex];
    
    setDrawings(prev => {
        const newState = { ...prev, [currentPlayer.id]: dataUrl };
        return newState;
    });

    setTimeout(() => {
        const nextIndex = currentPlayerIndex + 1;
        if (nextIndex < players.length) {
            setCurrentPlayerIndex(nextIndex);
            setPhase('interlude');
        } else {
            setPhase('ready_presentation');
            setCurrentPresenterIndex(0);
        }
    }, 10);
  };

  const nextPresentation = () => {
    setPhase('presenting');
  };

  const finishPresentation = () => {
    setPhase('voting');
  };

  const handleVote = (winnerId) => {
    const currentArtistId = players[currentPresenterIndex].id;
    
    // Update Score
    setScores(prev => ({
      ...prev,
      [winnerId]: (prev[winnerId] || 0) + 1
    }));

    // Record the winner for this specific painting
    setPaintingWinners(prev => ({
      ...prev,
      [currentArtistId]: winnerId
    }));

    if (currentPresenterIndex < players.length - 1) {
      setCurrentPresenterIndex(prev => prev + 1);
      setPhase('presenting_interlude');
    } else {
      setPhase('result');
    }
  };

  const handleTitleChange = (artistId, criticId, value) => {
    setTitles(prev => ({
      ...prev,
      [artistId]: {
        ...(prev[artistId] || {}),
        [criticId]: value
      }
    }));
  };

  const resetGame = () => {
    setDrawings({});
    setScores({});
    setTitles({});
    setPaintingWinners({});
    players.forEach(p => setScores(prev => ({ ...prev, [p.id]: 0 })));
    setPhase('setup');
    setCurrentPlayerIndex(0);
    setCurrentPresenterIndex(0);
  };

  // --- Renders ---

  // 1. Setup Phase
  if (phase === 'setup') {
    const isMaxPlayers = players.length >= MAX_PLAYERS;

    return (
      <div className="min-h-screen bg-stone-900 text-stone-100 p-4 font-sans flex items-center justify-center">
        {showRules && <RuleModal onClose={() => setShowRules(false)} />}

        <div className="max-w-md w-full bg-stone-800 p-8 rounded-2xl shadow-2xl border border-stone-700 relative">
          
          <button 
             onClick={() => setShowRules(true)}
             className="absolute top-4 right-4 p-2 text-stone-400 hover:text-yellow-500 transition-colors"
             title="遊び方を見る"
          >
             <HelpCircle size={24} />
          </button>

          <div className="text-center mb-8">
            <div className="mx-auto w-16 h-16 bg-yellow-600 rounded-full flex items-center justify-center mb-4 shadow-lg ring-4 ring-yellow-600/30">
              <Paintbrush size={32} className="text-white" />
            </div>
            <h1 className="text-2xl font-serif font-bold text-yellow-500 mb-2 leading-tight">とんでも絵画を名作に！<br/>名画化選手権</h1>
            <p className="text-stone-400 text-sm">描いて、語って、騙し通せ。</p>
          </div>

          <form onSubmit={addPlayer} className="mb-4">
            <div className="flex gap-2">
              <input
                type="text"
                value={currentInput}
                onChange={(e) => setCurrentInput(e.target.value)}
                placeholder={isMaxPlayers ? "人数上限です" : "プレイヤー名"}
                disabled={isMaxPlayers}
                className="flex-grow bg-stone-900 border border-stone-600 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-yellow-500 transition-colors disabled:opacity-50"
              />
              <button 
                type="submit" 
                disabled={!currentInput.trim() || isMaxPlayers} 
                className="bg-yellow-600 hover:bg-yellow-700 text-white p-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <ChevronRight />
              </button>
            </div>
          </form>
          
          <div className="flex justify-end mb-4 text-xs text-stone-500">
            参加人数: {players.length} / {MAX_PLAYERS}
          </div>

          <div className="space-y-2 mb-8 max-h-48 overflow-y-auto">
            {players.map((p) => (
              <div key={p.id} className="flex justify-between items-center bg-stone-700 p-3 rounded-lg animate-fadeIn">
                <span className="font-bold flex items-center gap-2">
                  <User size={16} className="text-stone-400"/> {p.name}
                </span>
                <button onClick={() => removePlayer(p.id)} className="text-red-400 hover:text-red-300 p-1">
                  ✕
                </button>
              </div>
            ))}
            {players.length === 0 && (
              <p className="text-center text-stone-500 italic">プレイヤーを追加してください (3〜{MAX_PLAYERS}人)</p>
            )}
          </div>

          <div className="flex flex-col gap-3">
            <Button onClick={startGame} className="w-full" disabled={players.length < MIN_PLAYERS}>
              ゲーム開始 <Play size={20} fill="currentColor" />
            </Button>
            <button 
              onClick={() => setShowRules(true)} 
              className="text-stone-400 text-sm underline hover:text-stone-200 transition-colors"
            >
              ルールを確認する
            </button>
          </div>
        </div>
      </div>
    );
  }

  // 2. Drawing Phase (and Interlude)
  if (phase === 'drawing') {
    return (
      <div className="min-h-screen bg-gray-950 p-4 flex flex-col items-center justify-center">
        <DrawingCanvas 
          key={players[currentPlayerIndex].id}
          playerName={players[currentPlayerIndex].name} 
          onSave={handleDrawingSave} 
        />
      </div>
    );
  }

  if (phase === 'interlude') {
    return (
      <div className="min-h-screen bg-stone-900 text-white p-4 flex flex-col items-center justify-center text-center">
        <h2 className="text-2xl text-stone-400 mb-4">次のアーティストへ渡してください</h2>
        <div className="text-5xl font-serif font-bold text-yellow-500 mb-8 animate-bounce">
          {players[currentPlayerIndex].name} さん
        </div>
        <p className="mb-8 max-w-xs mx-auto text-stone-300">
          画面を見ずに受け取ったらボタンを押して描画を開始してください。
        </p>
        <Button onClick={() => setPhase('drawing')}>
          描画を始める <Paintbrush size={20} />
        </Button>
      </div>
    );
  }

  // 3. Pre-Presentation Ready Screen
  if (phase === 'ready_presentation') {
    return (
      <div className="min-h-screen bg-stone-900 text-white p-4 flex flex-col items-center justify-center text-center">
        <Palette size={64} className="text-yellow-500 mb-6" />
        <h1 className="text-3xl font-serif font-bold mb-4">全員の作品が<br/>完成しました</h1>
        <p className="mb-8 text-stone-400 max-w-md">
          これより「適当絵画 鑑賞会」を始めます。<br/>
          作者以外のプレイヤーは、表示される絵がいかに「傑作」であるか、
          もっともらしい言葉でプレゼンしてください。
        </p>
        <Button onClick={nextPresentation}>
          鑑賞会を始める <Award size={20} />
        </Button>
      </div>
    );
  }

   if (phase === 'presenting_interlude') {
    return (
      <div className="min-h-screen bg-stone-900 text-white p-4 flex flex-col items-center justify-center text-center">
        <h2 className="text-2xl text-stone-400 mb-4">次の作品</h2>
        <div className="text-4xl font-serif font-bold text-yellow-500 mb-8">
          作者：{players[currentPresenterIndex].name}
        </div>
        <Button onClick={nextPresentation}>
          作品を公開する <ChevronRight size={20} />
        </Button>
      </div>
    );
  }

  // 4. Presentation & Voting Phase
  if (phase === 'presenting' || phase === 'voting') {
    const artist = players[currentPresenterIndex];
    const imageSrc = drawings[artist.id];
    const critics = players.filter(p => p.id !== artist.id);

    return (
      <div className="min-h-screen bg-stone-950 text-stone-100 flex flex-col items-center overflow-y-auto pb-10">
        {/* Header */}
        <div className="w-full bg-stone-900 p-4 shadow-md mb-6 sticky top-0 z-10 border-b border-stone-800">
           <div className="max-w-4xl mx-auto flex justify-between items-center">
             <div>
               <p className="text-xs text-stone-400 uppercase tracking-widest">Masterpiece No. {currentPresenterIndex + 1}</p>
               <h2 className="text-xl font-serif text-yellow-500">作者: {artist.name}</h2>
             </div>
             {phase === 'presenting' && (
                <div className="text-xs bg-red-900 text-red-200 px-3 py-1 rounded-full animate-pulse">
                   鑑賞中
                </div>
             )}
           </div>
        </div>

        {/* The Art */}
        <div className="relative px-8 py-8 mb-6">
           {/* Frame Effect */}
           <div className="absolute inset-0 bg-yellow-700 rounded-lg shadow-2xl transform rotate-1"></div>
           <div className="absolute inset-2 bg-stone-800 border-4 border-yellow-600 border-double rounded shadow-inner"></div>
           
           {/* Image */}
           <div className="relative z-10 bg-white p-4 shadow-xl max-w-lg mx-auto" style={{ minWidth: '300px' }}>
              {imageSrc ? (
                <img src={imageSrc} alt="Masterpiece" className="w-full h-auto border border-stone-200" />
              ) : (
                <div className="w-full h-64 flex flex-col items-center justify-center bg-gray-200 text-gray-500 border border-dashed border-gray-400 p-4 text-center">
                    <p>作品データが見つかりません</p>
                    <p className="text-xs mt-2">ID: {artist.id}</p>
                </div>
              )}
              <div className="mt-4 text-center">
                 <p className="font-serif text-gray-800 text-lg italic">"Untitled No. {Math.floor(Math.random() * 900) + 100}"</p>
                 <p className="text-xs text-gray-500 mt-1">Estimated Value: ${Math.floor(Math.random() * 50) + 1}0,000,000</p>
              </div>
           </div>
        </div>

        {/* Instructions & Timer */}
        <div className="max-w-2xl w-full px-6 mb-8 text-center">
          {phase === 'presenting' ? (
             <div className="animate-slideUp">
               <h3 className="text-2xl font-bold mb-4 text-yellow-100">批評の時間 & タイトル付与</h3>
               <p className="text-stone-300 mb-6 leading-relaxed text-sm">
                 作者以外の全員、この絵のタイトルを考え入力し、
                 いかに「傑作」であるかを順番に熱く語ってください。
               </p>

               <div className="bg-stone-800 p-4 rounded-xl border border-stone-700 mb-6 text-left">
                  <h4 className="text-sm text-stone-400 mb-3 font-bold flex items-center gap-2">
                    <Type size={16}/> タイトル入力欄 (プレゼン時に記入)
                  </h4>
                  <div className="space-y-3">
                    {critics.map(critic => (
                      <div key={critic.id} className="flex flex-col sm:flex-row sm:items-center gap-2">
                        <span className="text-stone-300 w-24 font-bold text-sm truncate">{critic.name}:</span>
                        <input
                          type="text"
                          placeholder="ここへタイトルを入力..."
                          value={titles[artist.id]?.[critic.id] || ''}
                          onChange={(e) => handleTitleChange(artist.id, critic.id, e.target.value)}
                          className="flex-grow bg-stone-900 border border-stone-600 rounded px-3 py-2 text-white focus:outline-none focus:border-yellow-500 text-sm"
                        />
                      </div>
                    ))}
                  </div>
               </div>

               {/* Insert Timer Here */}
               <PresentationTimer />

               <div className="mt-8">
                <Button onClick={finishPresentation} variant="success" className="w-full sm:w-auto mx-auto">
                  全員のプレゼン終了・評価へ <Check size={20} />
                </Button>
               </div>
             </div>
          ) : (
            <div className="animate-slideUp bg-stone-800 p-6 rounded-xl border border-stone-700">
              <h3 className="text-2xl font-bold mb-2 text-yellow-400">ベスト・キュレーター選定</h3>
              <p className="text-stone-300 mb-6">
                作者（{artist.name}）は、最も素晴らしい「タイトル」と「批評」をした人を選んでください。
              </p>
              
              <div className="grid grid-cols-1 gap-3">
                {critics.map(critic => {
                  const title = titles[artist.id]?.[critic.id] || "（無題）";
                  return (
                    <button
                      key={critic.id}
                      onClick={() => handleVote(critic.id)}
                      className="flex flex-col items-start p-4 bg-stone-700 hover:bg-yellow-800 border border-stone-600 hover:border-yellow-500 rounded-lg transition-all group text-left"
                    >
                      <div className="flex justify-between w-full mb-1">
                        <span className="text-sm text-stone-400">{critic.name}</span>
                        <Award className="text-stone-500 group-hover:text-yellow-400" size={20} />
                      </div>
                      <span className="font-serif font-bold text-lg text-white group-hover:text-yellow-100">
                        『{title}』
                      </span>
                    </button>
                  );
                })}
              </div>
            </div>
          )}
        </div>
      </div>
    );
  }

  // 5. Final Results
  if (phase === 'result') {
    const sortedPlayers = [...players].sort((a, b) => (scores[b.id] || 0) - (scores[a.id] || 0));
    const winner = sortedPlayers[0];

    return (
      <div className="min-h-screen bg-stone-900 text-stone-100 p-4 font-sans flex flex-col items-center justify-center">
        <div className="max-w-2xl w-full bg-stone-800 p-8 rounded-2xl shadow-2xl border border-stone-700 text-center animate-fadeIn">
          <Trophy size={64} className="mx-auto text-yellow-500 mb-6" />
          <h1 className="text-4xl font-serif font-bold text-white mb-2">最終結果</h1>
          <p className="text-stone-400 mb-8">最も優れた審美眼とトーク力を持つのは...</p>

          <div className="bg-gradient-to-r from-yellow-900/50 to-stone-800 p-6 rounded-xl border border-yellow-700/50 mb-8 transform scale-105 shadow-xl">
             <p className="text-yellow-200 text-sm uppercase tracking-widest mb-2">Grand Champion</p>
             <p className="text-4xl font-bold text-white">{winner.name}</p>
             <p className="text-xl text-yellow-500 mt-2">{scores[winner.id] || 0} Points</p>
          </div>

          <div className="space-y-3 mb-10 text-left">
            {sortedPlayers.slice(1).map((p, idx) => (
              <div key={p.id} className="flex justify-between items-center bg-stone-700 p-4 rounded-lg">
                <div className="flex items-center gap-4">
                  <span className="text-stone-500 font-mono text-xl w-6">#{idx + 2}</span>
                  <span className="font-bold">{p.name}</span>
                </div>
                <span className="text-yellow-500 font-bold">{scores[p.id] || 0} pts</span>
              </div>
            ))}
          </div>
          
          <div className="flex flex-col gap-3">
             <Button onClick={() => setPhase('gallery')} variant="dark" className="w-full">
               <ImageIcon size={20} /> 美術館で作品を鑑賞する
             </Button>
             <Button onClick={resetGame} variant="secondary" className="w-full">
               もう一度遊ぶ <RotateCcw size={20} />
             </Button>
          </div>
        </div>
      </div>
    );
  }

  // 6. Gallery Phase
  if (phase === 'gallery') {
    return (
      <div className="min-h-screen bg-stone-950 text-stone-100 p-6 font-sans overflow-y-auto">
        <div className="max-w-6xl mx-auto">
          <div className="flex justify-between items-center mb-10 border-b border-stone-800 pb-4">
            <h1 className="text-3xl font-serif font-bold text-yellow-500 tracking-wider">THE MUSEUM OF ACCIDENTAL ART</h1>
            <Button onClick={resetGame} variant="secondary" className="px-4 py-2 text-sm">
              タイトルに戻る <RotateCcw size={16} />
            </Button>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-12 pb-12">
            {players.map((artist) => {
              const drawing = drawings[artist.id];
              const winnerId = paintingWinners[artist.id]; 
              const winningTitle = titles[artist.id]?.[winnerId] || "（無題）";
              const winningCritic = players.find(p => p.id === winnerId);
              
              const otherCritics = players.filter(p => p.id !== artist.id && p.id !== winnerId);

              return (
                <div key={artist.id} className="flex flex-col items-center animate-fadeIn">
                  {/* Frame */}
                  <div className="relative p-2 bg-yellow-900/30 rounded-lg shadow-2xl mb-6 transform hover:scale-105 transition-transform duration-500">
                    <div className="absolute inset-0 bg-yellow-800 rounded-lg shadow-xl opacity-50"></div>
                    <div className="relative border-8 border-yellow-700 border-double bg-white p-2 shadow-inner">
                       <img src={drawing} alt="Artwork" className="w-full h-auto object-cover max-h-64" style={{ minHeight: '200px' }} />
                    </div>
                  </div>

                  {/* Plaque */}
                  <div className="bg-stone-100 text-stone-900 p-4 rounded shadow-lg w-full max-w-sm relative">
                    <div className="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-4 h-4 bg-stone-300 rounded-full shadow-inner border border-stone-400"></div>
                    
                    <h3 className="font-serif font-bold text-xl mb-1 leading-tight text-center">
                      『{winningTitle}』
                    </h3>
                    <div className="text-center mb-3">
                      <p className="text-xs text-stone-500 uppercase tracking-widest">Artist</p>
                      <p className="font-bold">{artist.name}</p>
                    </div>
                    
                    <div className="border-t border-stone-300 pt-2 mb-2">
                       <p className="text-xs text-stone-500 uppercase tracking-widest text-center mb-1">Curated By</p>
                       <p className="text-center font-bold text-yellow-700">{winningCritic?.name || "Unknown"}</p>
                    </div>

                    {/* Other Titles */}
                    {otherCritics.length > 0 && (
                      <div className="mt-3 pt-2 border-t border-stone-200">
                        <p className="text-[10px] text-stone-400 uppercase tracking-widest mb-1">Other Interpretations</p>
                        <ul className="text-xs text-stone-600 space-y-1">
                          {otherCritics.map(critic => (
                            <li key={critic.id} className="flex justify-between">
                              <span className="italic truncate mr-2">"{titles[artist.id]?.[critic.id] || 'Untitled'}"</span>
                              <span className="text-stone-400 flex-shrink-0">- {critic.name}</span>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      </div>
    );
  }

  return null;
}
